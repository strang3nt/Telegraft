@startuml clientRequest

mainframe **cd** ClientRequest
skinparam defaultFontSize 16

skinparam style strictuml
autoactivate on
autonumber

!pragma teoz true
skinparam sequenceMessageAlign direction

actor "gRPC client" as Client

boundary ":RaftClientServiceImpl" as RaftClientServiceImpl

participant ":Behavior[RaftServer.Command]" as TempActor

activate Client
{time_start} Client -> RaftClientServiceImpl: ClientRequest(clientId, requestId, payload)

RaftClientServiceImpl -> TempActor **: spawns
activate TempActor

participant "raftServer :Behavior[RaftServer.Command]" as raftServer

TempActor -> raftServer: ClientRequest(clientId, requestId, payload)

raftServer -> raftServer: ApplyToStateMachine(payload)

collections "server: Server" as server

loop for each server in config

  activate raftServer
  raftServer -> server: AppendEntriesRequest(payload)
  raftServer <-- server: AppendEntriesResponse()
  return AppendEntriesResponse



end



alt if payload is ready to be applied
  activate raftServer
  raftServer -> stateMachine: Send payload
  raftServer <-- stateMachine: Response
  return Response

  raftServer --> TempActor: Response
  RaftClientServiceImpl <-- TempActor: Response
  {time_end} RaftClientServiceImpl --> Client: Response
  {time_end} <-> {time_start} : less than 3s

else payload not ready to be applied
  loop until it can be applied or discarded
    raftServer -> raftServer: ApplyToStateMachine(payload)
  end
  RaftClientServiceImpl --> Client: Failure response
  deactivate Client
end



@enduml