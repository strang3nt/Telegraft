@startuml

skinparam groupInheritance 2

package com.telegraft.rafktor {

note as N0
  This diagram uses elements from
  the scala syntax: types are specified
  after ":" and type parameters are
  between squared brackets. Collections
  and types are the ones used in the actual
  code.
end note


  class Configuration {
    - servers: Set[String]
    + Configuration(servers: Set[String]): Configuration
    + getConfiguration(): Set[String]
    + getServer(server: String): String
  }

  note bottom of Configuration
    Servers are parsed from the provided
    configuration, and they are identified
    by the following string "interface:port"
  end note

  interface Server {

  }

  class ServerImpl

  namespace StateMachine {
    interface Command
  }

  class StateMachine << (S,#FF7700) Singleton >> {
    {static} +apply(): Behavior[Command]
  }




  namespace RaftServer {
    interface Command
    class AppendEntries
    class AppendEntriesResponse

    interface Event
    class EntriesApplied
    class AppendEntriesResponseEvent
  }

   note as N1
      There are more than the displayed
      implementations, but they are not
      shown for the sake of brevity.
    end note

    N1 .. RaftServer.Command
    N1 .. StateMachine.Command
    N1 .. RaftServer.Event

  namespace Log {
    class LogEntry
  }

  class Log {
    + logEntries: Vector[LogEntry]
    + Log(logEntries: Vector[LogEntry]): Log
    + apply(index: Int): LogEntry
    + length(): Int
    + lastLogTerm(): Long
    + appendEntries(newEntries: Log, prevLogIndex: Int): Log
    {static} + empty(): Log
  }

  class RaftServer << (S,#FF7700) Singleton >> {
    {static} +apply(serverId: String, stateMachine: ActorRef[StateMachine.Command], config: Configuration) : Behavior[Command]
    {static} - commandHandler(config: Configuration,
       timer: TimerScheduler[Command],
       context: ActorContext[Command],
       serverId: String,
       stateMachine: ActorRef[StateMachine.Command],
       s: RaftState,
       c: Command): ReplyEffect[Event, RaftState]
  }

  note right of RaftServer
    The <u>apply</u> method is a static
    method which returns a persistent
    actor.
  end note

  namespace RaftState {
    interface RaftState {
      Log: LogEntry[]
      currentTerm: Long
      votedFor: Option<String>
      log: Log
      commitIndex: Long
      lastApplied: Long

      + applyEvent(state: RaftState, event: Event): RaftState

    }
    class Leader {
      + matchIndex: Map[String, Long]
      + nextIndex: Map[String, Long]
    }
    class Follower
    class Candidate
  }

}

Log.LogEntry "1" --o "0..*" Log

StateMachine "0..*"..>"1" StateMachine.Command: Received by <

RaftServer.Command <|-- RaftServer.AppendEntries
RaftServer.Command <|-- RaftServer.AppendEntriesResponse

RaftServer.Event <|-- RaftServer.EntriesApplied
RaftServer.Event <|-- RaftServer.AppendEntriesResponseEvent

RaftState.RaftState <|-- RaftState.Leader
RaftState.RaftState <|-- RaftState.Follower
RaftState.RaftState <|-- RaftState.Candidate

RaftState.Leader "0..*"..>"1" RaftServer.Event: consumes >
RaftState.Follower "0..*"..>"1" RaftServer.Event: consumes >
RaftState.Candidate "0..*"..>"1" RaftServer.Event: consumes >

RaftState.Leader o-- Log: contains >
RaftState.Follower o-- Log: contains >
RaftState.Candidate o-- Log: contains >

Server <|-- ServerImpl
Configuration o-- Server


RaftServer ..> RaftState.RaftState: contains
RaftServer "0..*" ..> "1" RaftServer.Command: < is received by
RaftServer "0..*" ..> "1" RaftServer.Event: < is produced by
RaftServer "0..*" ..> "1" Server: sends messages to >
RaftServer "1" ..> Configuration: holds >
RaftServer "1" ..> StateMachine: sends messages to >

@enduml